<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mic Signal Processor (HPF & Gain)</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom font */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap');

        :root {
            --slider-height: 4px; 
            --thumb-size: 16px;   
            --fill-color: #5d98ff; /* Bright Blue for Active Fill and Thumb */
            --active-color: #4CAF50; /* Green for Mic Toggle */
            --knob-bg: #1a1a2e; /* Deep purple/dark blue */
            --track-color: #3b3b52; /* Darker, visible track */
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--knob-bg); 
        }

        /* --- SLIDER STYLING --- */

        .slider-control-group {
            position: relative;
            padding: 0 8px;
        }

        /* Base Range Input Styling */
        .custom-slider {
            -webkit-appearance: none;
            width: 100%;
            height: var(--slider-height);
            background: var(--track-color); 
            border-radius: 9999px; 
            cursor: pointer;
            z-index: 10;
            position: relative;
            box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.5);
            /* Initial track background fill (updated via JS) - uses bright fill color */
            background-image: linear-gradient(to right, var(--fill-color) 0%, transparent 0%);
            background-repeat: no-repeat;
        }

        /* --- THUMB STYLING (Webkit - Chrome, Safari) --- */
        .custom-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: var(--thumb-size);
            height: var(--thumb-size);
            /* Set the thumb to the bright fill color */
            background: var(--fill-color); 
            border: 2px solid var(--fill-color); /* Bright border color */
            border-radius: 50%;
            cursor: grab;
            margin-top: calc((var(--thumb-size) / 2) - (var(--slider-height) / 2) * -1); /* Center the thumb */
            transition: all 0.2s ease-out;
            /* Added subtle white inner glow for definition */
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.5), inset 0 0 5px rgba(255, 255, 255, 0.5);
        }

        /* --- THUMB STYLING (Moz - Firefox) --- */
        .custom-slider::-moz-range-thumb {
            width: var(--thumb-size);
            height: var(--thumb-size);
            /* Set the thumb to the bright fill color */
            background: var(--fill-color);
            border: 2px solid var(--fill-color); /* Bright border color */
            border-radius: 50%;
            cursor: grab;
            transition: all 0.2s ease-out;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.5), inset 0 0 5px rgba(255, 255, 255, 0.5);
        }

        /* --- MARKER DOTS/POINTS --- */
        .slider-points {
            position: absolute;
            top: 50%;
            left: 0;
            right: 0;
            transform: translateY(-50%);
            /* Adjusted height for thinner slider */
            height: calc(var(--slider-height) + 4px); 
            pointer-events: none; /* Ignore clicks on markers */
            z-index: 5;
            padding: 0 8px; /* Match the padding of the control group */
        }

        .slider-points .point {
            position: absolute;
            height: 4px; /* Reduced dot size */
            width: 4px;
            border-radius: 50%;
            background-color: #888; /* Dark/dim color for the markers */
            top: calc(50% - 2px); /* Adjusted top for centering */
            /* Use CSS custom property to position the point */
            left: var(--pos); 
            transform: translateX(-50%);
        }

        .slider-points .point.active-point {
            background-color: var(--fill-color); /* Bright blue color for active dots */
        }

        /* Status Light Glow */
        #status-light.active {
            box-shadow: 0 0 5px var(--active-color), 0 0 15px var(--active-color);
        }

        /* Custom Toggle Switch Styling */
        .toggle-label input:checked + .slider {
            background-color: var(--active-color); 
        }

        .toggle-label input:focus + .slider {
            box-shadow: 0 0 1px var(--active-color);
        }

        .toggle-label input:checked + .slider:before {
            transform: translateX(26px);
            background-color: #ffffff;
        }

        .toggle-label .slider {
            background-color: #ccc;
            transition: .4s;
        }

        .toggle-label .slider:before {
            background-color: white;
            transition: .4s;
        }
        
        /* Visualizer styling */
        #audio-visualizer {
            background-color: #1a1a2e;
            border-radius: 0.75rem;
            border-color: #4f46e5;
        }
        
        /* Dropdown Styling */
        .device-select {
            appearance: none;
            background-color: #1a1a2e;
            border: 1px solid #4f46e5;
            color: white;
            padding: 8px 12px;
            border-radius: 0.5rem;
            cursor: pointer;
            font-size: 0.875rem;
            line-height: 1.25rem;
            width: 100%;
            margin-top: 10px;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 20 20' fill='%236366f1'%3E%3Cpath fill-rule='evenodd' d='M5.23 7.21a.75.75 0 011.06.02L10 10.958l3.71-3.73a.75.75 0 111.06 1.06l-4.25 4.25a.75.75 0 01-1.06 0L5.21 8.27a.75.75 0 01.02-1.06z' clip-rule='evenodd' /%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 0.75rem center;
            background-size: 1.5em 1.5em;
            padding-right: 2.5rem;
        }
    </style>
</head>
<body class="min-h-screen flex items-center justify-center p-4">

    <div id="app" class="w-full max-w-lg bg-[#24243e] p-8 rounded-3xl shadow-2xl border border-indigo-700/50">
        <!-- Header -->
        <h1 class="text-3xl font-extrabold text-white text-center mb-2 tracking-wider">
            FM Signal Processor
        </h1>
        <p class="text-sm text-indigo-300 text-center mb-6">
            Microphone Input with HPF, Mid-Cut, Noise Gate, and Gain Control
        </p>
        
        <!-- Device Selection Dropdown -->
        <div class="mb-4">
            <label for="audio-input-select" class="text-xs font-medium text-indigo-300 block mb-1">SELECT AUDIO INPUT DEVICE</label>
            <select id="audio-input-select" class="device-select" title="Select Input Device">
                <option value="default">Default Microphone</option>
            </select>
        </div>

        <!-- Status and Enable Switch -->
        <div class="flex items-center justify-between mb-8 p-4 rounded-xl bg-[#1a1a2e] shadow-inner">
            <div class="flex items-center space-x-3">
                <div id="status-light" class="w-4 h-4 rounded-full bg-gray-500 shadow-lg transition-all duration-300"></div>
                <span id="status-text" class="text-sm font-semibold text-gray-300">Mic Disabled</span>
            </div>

            <!-- Mic Enable Toggle Switch -->
            <label class="toggle-label relative inline-block w-14 h-8">
                <input type="checkbox" id="mic-toggle" class="opacity-0 w-0 h-0">
                <span class="slider absolute cursor-pointer top-0 left-0 right-0 bottom-0 bg-gray-400 rounded-full transition-all duration-400 before:absolute before:content-[''] before:h-6 before:w-6 before:left-1 before:bottom-1 before:bg-white before:rounded-full before:transition-all duration-400"></span>
            </label>
        </div>
        
        <!-- Live Audio Visualizer (Frequency Graph) -->
        <div class="flex justify-between px-1 mb-2 text-xs text-indigo-400">
            <span>Low Freq (Rumble)</span>
            <span>High Freq (Treble)</span>
        </div>
        <canvas id="audio-visualizer" class="w-full h-24 rounded-xl bg-[#1a1a2e] mb-8 border border-indigo-700/50"></canvas>
        

        <!-- Slider Controls -->
        <div class="flex flex-col space-y-12">
            
            <!-- 1. Gain Control Slider -->
            <div class="flex flex-col items-center">
                <p class="text-sm font-medium text-indigo-300 mb-3">OUTPUT GAIN</p>
                <!-- Displayed as Percentage -->
                <p id="gain-value" class="text-2xl font-bold text-white mb-4">50%</p>

                <div class="slider-control-group w-full">
                    <input type="range" min="0.0" max="1.5" value="0.25" step="0.01" class="custom-slider" id="gain-range" oninput="updateGain()">
                    <div class="slider-points" id="gain-points">
                        <!-- Points will be generated by JS -->
                    </div>
                </div>
                <!-- Labels below the slider for context -->
                <div class="flex justify-between w-full px-2 text-xs text-gray-500 mt-2">
                    <span class="text-white">0%</span>
                    <span>75%</span>
                    <span class="text-white">300%</span>
                </div>
            </div>

            <!-- 2. HPF Cutoff Slider (Rumble Filter) -->
            <div class="flex flex-col items-center">
                <p class="text-sm font-medium text-indigo-300 mb-3">HPF CUTOFF (Hz) - RUMBLE FILTER</p>
                <p id="hpf-value" class="text-2xl font-bold text-white mb-4">101 Hz</p>
                
                <div class="slider-control-group w-full">
                    <input type="range" min="20" max="400" value="101" step="1" class="custom-slider" id="hpf-range" oninput="updateHPF()">
                    <div class="slider-points" id="hpf-points">
                        <!-- Points will be generated by JS -->
                    </div>
                </div>
                <!-- Labels below the slider for context -->
                <div class="flex justify-between w-full px-2 text-xs text-gray-500 mt-2">
                    <span class="text-white">20 Hz</span>
                    <span>210 Hz</span>
                    <span class="text-white">400 Hz</span>
                </div>
            </div>
            
            <!-- 3. Mid-Cut Filter (Music/Tone Target) -->
            <div class="flex flex-col items-center">
                <p class="text-sm font-medium text-yellow-400 mb-3">MID-CUT FREQUENCY (Hz) - MUSIC TARGET</p>
                <p id="notch-value" class="text-2xl font-bold text-white mb-4">1700 Hz</p>
                
                <div class="slider-control-group w-full">
                    <input type="range" min="300" max="3000" value="1700" step="10" class="custom-slider" id="notch-range" oninput="updateNotch()">
                    <div class="slider-points" id="notch-points">
                        <!-- Points will be generated by JS -->
                    </div>
                </div>
                <!-- Labels below the slider for context -->
                <div class="flex justify-between w-full px-2 text-xs text-gray-500 mt-2">
                    <span class="text-white">300 Hz (Low Mid)</span>
                    <span>1650 Hz</span>
                    <span class="text-white">3000 Hz (High Mid)</span>
                </div>
            </div>


            <!-- 4. Noise Reduction Threshold (Hiss Filter) -->
            <div class="flex flex-col items-center">
                <p class="text-sm font-medium text-red-400 mb-3">NOISE REDUCTION THRESHOLD - HISS/STATIC</p>
                <p id="gate-value" class="text-2xl font-bold text-white mb-4">-20 dB</p>
                
                <div class="slider-control-group w-full">
                    <input type="range" min="-80" max="-5" value="-20" step="1" class="custom-slider" id="gate-range" oninput="updateGateThreshold()">
                    <div class="slider-points" id="gate-points">
                        <!-- Points will be generated by JS -->
                    </div>
                </div>
                <!-- Labels below the slider for context -->
                <div class="flex justify-between w-full px-2 text-xs text-gray-500 mt-2">
                    <span class="text-white">-80 dB (Silent)</span>
                    <span>-42.5 dB</span>
                    <span class="text-white">-5 dB (Loudest)</span>
                </div>
            </div>
            
        </div>

        <!-- Footer / Instructions -->
        <div class="mt-10 p-4 border-t border-indigo-700/50 text-xs text-gray-400 text-center">
            <p>HPF cuts low-frequency noise (rumble). **Mid-Cut** targets specific music/tone frequencies.</p>
            <p>**Noise Reduction** targets general background hiss/static when you are silent.</p>
        </div>
    </div>

    <script>
        // --- GLOBAL AUDIO VARIABLES ---
        let audioContext;
        let stream; 
        
        // Audio Processing Nodes
        let sourceNode;
        // Removed inputGainNode
        let hpfNode; 
        let bandStopNode; 
        let compressorNode; 
        let analyserNode; 
        let outputGainNode; 

        // --- DOM ELEMENTS ---
        const micToggle = document.getElementById('mic-toggle');
        const statusLight = document.getElementById('status-light');
        const statusText = document.getElementById('status-text');
        const visualizerCanvas = document.getElementById('audio-visualizer');
        const visualizerCtx = visualizerCanvas.getContext('2d');
        const audioInputSelect = document.getElementById('audio-input-select'); 

        // Slider elements 
        const outputGainRange = document.getElementById('gain-range');
        const outputGainValueDisplay = document.getElementById('gain-value');
        const outputGainPointsContainer = document.getElementById('gain-points');

        const hpfRange = document.getElementById('hpf-range');
        const hpfValueDisplay = document.getElementById('hpf-value');
        const hpfPointsContainer = document.getElementById('hpf-points');

        const notchRange = document.getElementById('notch-range');
        const notchValueDisplay = document.getElementById('notch-value');
        const notchPointsContainer = document.getElementById('notch-points');

        const gateRange = document.getElementById('gate-range');
        const gateValueDisplay = document.getElementById('gate-value');
        const gatePointsContainer = document.getElementById('gate-points');
        
        // Removed input gain DOM elements
        

        /**
         * Applies a custom gradient fill to the slider track up to the thumb's position.
         * @param {HTMLInputElement} slider The range input element.
         */
        function applySliderFill(slider) {
            const min = parseFloat(slider.min);
            const max = parseFloat(slider.max);
            const value = parseFloat(slider.value);
            
            const normalized = ((value - min) / (max - min)) * 100;
            
            const fillColor = getComputedStyle(document.documentElement).getPropertyValue('--fill-color');
            const trackColor = getComputedStyle(document.documentElement).getPropertyValue('--track-color'); 
            
            slider.style.background = `linear-gradient(to right, 
                ${fillColor} 0%, 
                ${fillColor} ${normalized}%, 
                ${trackColor} ${normalized}%, 
                ${trackColor} 100%)`;
        }

        /**
         * Generates the marker dots for a slider based on specific values.
         * @param {HTMLElement} container The DOM element to append markers to.
         * @param {HTMLInputElement} rangeEl The corresponding range input.
         * @param {Array<number>} points Array of values where markers should appear.
         */
        function generateSliderPoints(container, rangeEl, points) {
            container.innerHTML = '';
            const min = parseFloat(rangeEl.min);
            const max = parseFloat(rangeEl.max);

            points.forEach(pointValue => {
                const position = ((pointValue - min) / (max - min)) * 100;
                
                const point = document.createElement('div');
                point.className = 'point';
                point.style.setProperty('--pos', `${position}%`);
                point.dataset.value = pointValue;
                container.appendChild(point);
            });
        }
        
        /**
         * Checks which marker dots are "active" (passed by the current slider value).
         * @param {HTMLInputElement} rangeEl The corresponding range input.
         */
        function updateActivePoints(rangeEl) {
            const currentValue = parseFloat(rangeEl.value);
            const points = rangeEl.nextElementSibling.querySelectorAll('.point');

            points.forEach(point => {
                const pointValue = parseFloat(point.dataset.value);
                
                let shouldActivate = currentValue >= pointValue;
                
                if (rangeEl.id === 'gate-range') {
                    shouldActivate = pointValue <= currentValue;
                }
                
                if (shouldActivate) {
                    point.classList.add('active-point');
                } else {
                    point.classList.remove('active-point');
                }
            });
        }
        
        // --- VISUALIZER LOGIC (Unchanged) ---
        let frequencyDataArray;
        let bufferLength;

        function drawVisualizer() {
            visualizerCanvas.width = visualizerCanvas.offsetWidth;
            visualizerCanvas.height = visualizerCanvas.offsetHeight;
            
            if (!analyserNode || analyserNode.frequencyBinCount !== bufferLength) {
                bufferLength = analyserNode ? analyserNode.frequencyBinCount : 0;
                frequencyDataArray = new Uint8Array(bufferLength);
            }
            
            function draw() {
                if (!analyserNode || !micToggle.checked) {
                    visualizerCtx.clearRect(0, 0, visualizerCanvas.width, visualizerCanvas.height);
                    return; 
                }

                requestAnimationFrame(draw);
                analyserNode.getByteFrequencyData(frequencyDataArray);
                visualizerCtx.clearRect(0, 0, visualizerCanvas.width, visualizerCanvas.height);

                const binsToDraw = 400; 
                const barWidth = (visualizerCanvas.width / binsToDraw);
                let x = 0;
                
                for (let i = 0; i < binsToDraw; i++) {
                    let barHeight = frequencyDataArray[i] * (visualizerCanvas.height / 255) * 1.5;
                    let color;
                    
                    if (i < 10) { color = '#8be9fd'; } 
                    else if (i < 50) { color = '#5d98ff'; } 
                    else if (i < 200) { color = '#fffb92'; } 
                    else { color = '#ff6b81'; }

                    if (barHeight > 5) { visualizerCtx.fillStyle = color; } 
                    else { visualizerCtx.fillStyle = '#3b3b52'; }

                    visualizerCtx.fillRect(x, visualizerCanvas.height - barHeight, barWidth - 1, barHeight);
                    x += barWidth;
                }
            }
            
            draw();
        }
        
        // --- DEVICE SELECTION LOGIC (Unchanged) ---
        async function getAudioInputDevices() {
            try {
                // Request mic access (will prompt user)
                await navigator.mediaDevices.getUserMedia({ audio: true, video: false }); 
                
                const devices = await navigator.mediaDevices.enumerateDevices();
                
                audioInputSelect.innerHTML = '';
                
                let foundMic = false;
                devices.forEach(device => {
                    if (device.kind === 'audioinput') {
                        foundMic = true;
                        const option = document.createElement('option');
                        option.value = device.deviceId;
                        option.text = device.label || `Microphone (${device.deviceId.substring(0, 8)}...)`;
                        audioInputSelect.appendChild(option);
                    }
                });

                if (!foundMic) {
                    const option = document.createElement('option');
                    option.value = 'default';
                    option.text = 'No Microphones Found';
                    audioInputSelect.appendChild(option);
                }
            } catch (error) {
                console.error("Error enumerating devices or accessing mic:", error);
                audioInputSelect.innerHTML = '<option value="error">Access Denied/Error</option>';
            }
        }
        
        // --- AUDIO INITIALIZATION ---

        async function initializeAudio() {
            try {
                if (!audioContext || audioContext.state === 'closed') {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)({ 
                        sampleRate: 48000,
                        latencyHint: 'interactive' 
                    });
                } else if (audioContext.state === 'suspended') {
                    await audioContext.resume();
                }
                
                // Get selected device ID
                const selectedDeviceId = audioInputSelect.value;
                
                // Constraints now use the selected device ID
                stream = await navigator.mediaDevices.getUserMedia({ 
                    audio: {
                        deviceId: selectedDeviceId ? { exact: selectedDeviceId } : undefined,
                        echoCancellation: false, 
                        noiseSuppression: false,
                        autoGainControl: false,
                        latency: 0 
                    }
                });

                // 1. Create Nodes
                sourceNode = audioContext.createMediaStreamSource(stream);
                // Removed inputGainNode creation
                hpfNode = audioContext.createBiquadFilter();
                bandStopNode = audioContext.createBiquadFilter(); 
                compressorNode = audioContext.createDynamicsCompressor(); 
                analyserNode = audioContext.createAnalyser(); 
                analyserNode.fftSize = 2048; 
                outputGainNode = audioContext.createGain(); 

                // 2. Configure Nodes 
                // Removed input gain configuration

                hpfNode.type = "highpass";
                hpfNode.Q.setValueAtTime(1.0, audioContext.currentTime);
                hpfNode.frequency.setValueAtTime(parseFloat(hpfRange.value), audioContext.currentTime);
                
                bandStopNode.type = "notch";
                bandStopNode.Q.setValueAtTime(15, audioContext.currentTime); 
                bandStopNode.frequency.setValueAtTime(parseFloat(notchRange.value), audioContext.currentTime);

                compressorNode.threshold.setValueAtTime(parseFloat(gateRange.value), audioContext.currentTime); 
                compressorNode.ratio.setValueAtTime(20, audioContext.currentTime);
                compressorNode.attack.setValueAtTime(0.005, audioContext.currentTime); 
                compressorNode.release.setValueAtTime(0.3, audioContext.currentTime); 

                outputGainNode.gain.setValueAtTime(parseFloat(outputGainRange.value), audioContext.currentTime);

                // 3. Build the Audio Graph: Source -> HPF -> Notch -> Gate -> Analyser -> Output Gain -> Destination
                sourceNode.connect(hpfNode); // Directly connect source to HPF
                hpfNode.connect(bandStopNode); 
                bandStopNode.connect(compressorNode); 
                compressorNode.connect(analyserNode); 
                analyserNode.connect(outputGainNode); 
                outputGainNode.connect(audioContext.destination);

                return true;

            } catch (error) {
                console.error("Error accessing microphone or initializing audio:", error);
                statusLight.className = 'w-4 h-4 rounded-full bg-red-500 shadow-lg';
                statusText.textContent = `Error: Cannot start device: ${audioInputSelect.options[audioInputSelect.selectedIndex].text}`;
                micToggle.checked = false; 
                return false;
            }
        }

        // --- STOP AUDIO (Updated) ---
        function stopAudio() {
            if (stream) {
                stream.getTracks().forEach(track => track.stop());
                stream = null;
            }
            if (audioContext && audioContext.state !== 'closed') {
                audioContext.close().catch(e => console.error("Error closing context:", e));
                audioContext = null;
            }
            // Clear references
            sourceNode = null;
            // Removed inputGainNode reference
            hpfNode = null;
            bandStopNode = null; 
            compressorNode = null;
            analyserNode = null;
            outputGainNode = null;
            
            statusLight.className = 'w-4 h-4 rounded-full bg-gray-500 shadow-lg transition-all duration-300';
            statusText.textContent = 'Mic Disabled';
            
            visualizerCtx.clearRect(0, 0, visualizerCanvas.width, visualizerCanvas.height);
        }

        // --- UI & AUDIO UPDATE HANDLERS (Removed Input Gain logic) ---
        
        // Removed updateInputGain function
        
        function updateGain() {
            const gainValue = parseFloat(outputGainRange.value);

            if (outputGainNode) {
                if (audioContext && audioContext.state !== 'closed') {
                    outputGainNode.gain.setValueAtTime(gainValue, audioContext.currentTime);
                }
            }
            
            const normalized = gainValue / 0.5;
            const gainPercent = Math.round(normalized * 100);
            outputGainValueDisplay.textContent = `${gainPercent}%`;

            applySliderFill(outputGainRange);
            updateActivePoints(outputGainRange);
        }

        function updateHPF() {
            const hpfFreq = parseFloat(hpfRange.value);

            if (hpfNode) {
                if (audioContext && audioContext.state !== 'closed') {
                    hpfNode.frequency.exponentialRampToValueAtTime(hpfFreq, audioContext.currentTime + 0.05);
                }
            }

            hpfValueDisplay.textContent = `${hpfFreq} Hz`;

            applySliderFill(hpfRange);
            updateActivePoints(hpfRange);
        }
        
        function updateNotch() {
            const notchFreq = parseFloat(notchRange.value);
            
            if (bandStopNode) {
                 if (audioContext && audioContext.state !== 'closed') {
                    bandStopNode.frequency.exponentialRampToValueAtTime(notchFreq, audioContext.currentTime + 0.05);
                }
            }

            notchValueDisplay.textContent = `${notchFreq} Hz`;

            applySliderFill(notchRange);
            updateActivePoints(notchRange);
        }

        function updateGateThreshold() {
            const threshold = parseFloat(gateRange.value);
            
            if (compressorNode) {
                if (audioContext && audioContext.state !== 'closed') {
                    compressorNode.threshold.setValueAtTime(threshold, audioContext.currentTime);
                }
            }

            gateValueDisplay.textContent = `${threshold} dB`;

            applySliderFill(gateRange);
            updateActivePoints(gateRange);
        }


        /**
         * Main event listener for the mic toggle switch.
         */
        micToggle.addEventListener('change', async (event) => {
            if (event.target.checked) {
                // Stop audio first if devices are being changed
                if (stream) {
                    stopAudio();
                }
                
                statusLight.className = 'w-4 h-4 rounded-full bg-yellow-500 shadow-lg active animate-pulse';
                statusText.textContent = 'Starting Mic...';

                const success = await initializeAudio();

                if (success) {
                    statusLight.className = 'w-4 h-4 rounded-full bg-green-500 shadow-lg active';
                    statusText.textContent = 'Mic Active & Processing';
                    
                    drawVisualizer(); 
                    // Initialize controls after audio context is ready
                    updateGain();
                    updateHPF();
                    updateNotch(); 
                    updateGateThreshold();
                } else {
                    event.target.checked = false;
                }

            } else {
                stopAudio();
            }
        });
        
        // --- Handle Device Change (Unchanged) ---
        audioInputSelect.addEventListener('change', () => {
            if (micToggle.checked) {
                micToggle.checked = false; 
                stopAudio();
            }
        });


        // --- INITIAL SETUP (Run on Load) ---
        window.onload = () => {
            // First: Get all available input devices
            getAudioInputDevices();
            
            // Define marker points for each slider
            // Removed input gain marker definition
            generateSliderPoints(outputGainPointsContainer, outputGainRange, [0.0, 0.5, 1.0, 1.5]);
            generateSliderPoints(hpfPointsContainer, hpfRange, [20, 50, 101, 150, 250, 400]);
            generateSliderPoints(notchPointsContainer, notchRange, [300, 750, 1700, 2250, 3000]);
            generateSliderPoints(gatePointsContainer, gateRange, [-80, -60, -40, -20, -5]);

            // Set initial display values and fill
            // Removed updateInputGain call
            updateGain();
            updateHPF();
            updateNotch(); 
            updateGateThreshold();

            // Resume audio context on first user interaction for compatibility
            document.addEventListener('click', () => {
                if (audioContext && audioContext.state === 'suspended') {
                    audioContext.resume();
                }
            }, { once: true });
        };

    </script>
</body>
</html>
