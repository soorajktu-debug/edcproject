<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mic Signal Processor (HPF & Gain)</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom font */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap');

        :root {
            --knob-size: 120px;
            --neon-color: #a0a0ff; /* Purple Neon */
            --active-color: #4CAF50;
            --knob-bg: #1a1a2e; /* Deep purple/dark blue */
            --knob-face-color: #24243e; /* Slightly lighter face color */
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--knob-bg); 
        }

        /* KNOP STYLING: The container is static and holds the fill effect */
        .knob-container {
            position: relative;
            width: var(--knob-size);
            height: var(--knob-size);
            border-radius: 50%;
            /* Static background for non-filled area (matches body color) */
            background-color: var(--knob-bg); 
            z-index: 1;
        }

        /* New element for the dynamic fill (The rotating neon light) */
        .knob-fill {
            position: absolute;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            z-index: 5;
            /* Start point for the gradient is offset to MIN_ANGLE (-135deg) */
            transform: rotate(225deg); 
            
            /* --- THINNER RING MASK IMPLEMENTATION --- */
            /* Creates a thin ring from 83% to 87% of the radius (approx 2.4px thick) */
            -webkit-mask: radial-gradient(circle at center, transparent 83%, black 83%, black 87%, transparent 87%);
            mask: radial-gradient(circle at center, transparent 83%, black 83%, black 87%, transparent 87%);
            
            /* Add strong neon shadow for the filled part of the thin ring */
            box-shadow: 0 0 5px var(--neon-color), 0 0 15px var(--neon-color);
        }

        /* The rotating part (the physical knob face) */
        .knob-face { 
            position: absolute;
            top: 50%;
            left: 50%;
            width: calc(var(--knob-size) - 20px); 
            height: calc(var(--knob-size) - 20px);
            /* Reset transform to center it before applying rotation */
            transform: translate(-50%, -50%); 
            border-radius: 50%;
            background: linear-gradient(145deg, #2a2a48, #16162a);
            /* Soft deep shadow for 3D look (no neon glow on the face) */
            box-shadow: 8px 8px 15px #10101d, -8px -8px 15px #20203f;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: grab; 
            user-select: none;
            transition: transform 0.1s ease-out;
            touch-action: none; 
            z-index: 10;
        }

        /* Visually hide the input range slider but keep it functional */
        .knob-input {
            position: absolute;
            width: 100%;
            height: 100%;
            opacity: 0;
            cursor: grab;
            z-index: 15; /* Put above knob-face to capture clicks/touches */
        }

        /* Marker position on the knob */
        .knob-marker-indicator {
            position: absolute;
            width: 4px;
            height: 20px;
            background-color: var(--neon-color);
            top: 5px;
            left: calc(50% - 2px);
            border-radius: 2px;
            /* Neon glow for the indicator line */
            box-shadow: 0 0 4px var(--neon-color), 0 0 8px var(--neon-color); 
        }

        /* Status Light Glow */
        #status-light.active {
            box-shadow: 0 0 5px var(--active-color), 0 0 15px var(--active-color);
        }

        /* Custom Toggle Switch Styling (retained from previous version) */
        .toggle-label input:checked + .slider {
            background-color: var(--active-color); 
        }

        .toggle-label input:focus + .slider {
            box-shadow: 0 0 1px var(--active-color);
        }

        .toggle-label input:checked + .slider:before {
            transform: translateX(26px);
            background-color: #ffffff;
        }

        .toggle-label .slider {
            background-color: #ccc;
            transition: .4s;
        }

        .toggle-label .slider:before {
            background-color: white;
            transition: .4s;
        }
    </style>
</head>
<body class="min-h-screen flex items-center justify-center p-4">

    <div id="app" class="w-full max-w-lg bg-[#24243e] p-8 rounded-3xl shadow-2xl border border-indigo-700/50">
        <!-- Header -->
        <h1 class="text-3xl font-extrabold text-white text-center mb-2 tracking-wider">
            FM Signal Processor
        </h1>
        <p class="text-sm text-indigo-300 text-center mb-6">
            Microphone Input with HPF and Gain Control
        </p>

        <!-- Status and Enable Switch -->
        <div class="flex items-center justify-between mb-8 p-4 rounded-xl bg-[#1a1a2e] shadow-inner">
            <div class="flex items-center space-x-3">
                <div id="status-light" class="w-4 h-4 rounded-full bg-gray-500 shadow-lg transition-all duration-300"></div>
                <span id="status-text" class="text-sm font-semibold text-gray-300">Mic Disabled</span>
            </div>

            <!-- Mic Enable Toggle Switch -->
            <label class="toggle-label relative inline-block w-14 h-8">
                <input type="checkbox" id="mic-toggle" class="opacity-0 w-0 h-0">
                <span class="slider absolute cursor-pointer top-0 left-0 right-0 bottom-0 bg-gray-400 rounded-full transition-all duration-400 before:absolute before:content-[''] before:h-6 before:w-6 before:left-1 before:bottom-1 before:bg-white before:rounded-full before:transition-all duration-400"></span>
            </label>
        </div>

        <!-- Knob Controls -->
        <div class="flex flex-col sm:flex-row justify-around items-center space-y-8 sm:space-y-0 sm:space-x-4">

            <!-- 1. Gain Control Knob -->
            <div class="flex flex-col items-center">
                <div class="knob-container">
                    <!-- Static element for the neon fill effect -->
                    <div id="gain-fill" class="knob-fill"></div>

                    <!-- The rotating knob face (used to track rotation, previously .knob-base) -->
                    <div id="gain-knob" class="knob-face shadow-xl">
                        <div class="knob-marker-indicator"></div>
                    </div>
                    <!-- Hidden input range to handle the value logic (with sensitivity data) -->
                    <!-- This sits on top to easily capture mouse/touch events -->
                    <input type="range" min="0.0" max="3.0" value="1.0" step="0.01" class="knob-input" id="gain-range" data-sensitivity="0.005">
                </div>
                <p class="text-sm font-medium text-indigo-300 mt-3">OUTPUT GAIN</p>
                <!-- Displayed as Percentage -->
                <p id="gain-value" class="text-xl font-bold text-white mt-1">100%</p>
            </div>

            <!-- 2. HPF Cutoff Knob -->
            <div class="flex flex-col items-center">
                <div class="knob-container">
                    <!-- Static element for the neon fill effect -->
                    <div id="hpf-fill" class="knob-fill"></div>

                    <!-- The rotating knob face -->
                    <div id="hpf-knob" class="knob-face shadow-xl">
                        <div class="knob-marker-indicator"></div>
                    </div>
                    <!-- Hidden input range to handle the value logic (with increased sensitivity) -->
                    <input type="range" min="20" max="400" value="80" step="1" class="knob-input" id="hpf-range" data-sensitivity="0.8">
                </div>
                <p class="text-sm font-medium text-indigo-300 mt-3">HPF CUTOFF (Hz)</p>
                <p id="hpf-value" class="text-xl font-bold text-white mt-1">80 Hz</p>
            </div>
        </div>

        <!-- Footer / Instructions -->
        <div class="mt-10 p-4 border-t border-indigo-700/50 text-xs text-gray-400 text-center">
            <p>Ensure an audio device (like speakers/aux) is connected to hear the processed microphone signal.</p>
            <p>HPF (High-Pass Filter) cuts low-frequency noise. Start at 80 Hz.</p>
        </div>
    </div>

    <script>
        // --- GLOBAL AUDIO VARIABLES ---
        let audioContext;
        let sourceNode;
        let gainNode;
        let hpfNode;
        let stream; 

        // --- DOM ELEMENTS ---
        const micToggle = document.getElementById('mic-toggle');
        const statusLight = document.getElementById('status-light');
        const statusText = document.getElementById('status-text');

        // Knob elements
        const gainRange = document.getElementById('gain-range');
        const gainKnob = document.getElementById('gain-knob');
        const gainFill = document.getElementById('gain-fill');
        const gainValueDisplay = document.getElementById('gain-value');

        const hpfRange = document.getElementById('hpf-range');
        const hpfKnob = document.getElementById('hpf-knob');
        const hpfFill = document.getElementById('hpf-fill');
        const hpfValueDisplay = document.getElementById('hpf-value');

        const MIN_ANGLE = -135; // Start rotation angle for knob
        const MAX_ANGLE = 135;  // End rotation angle for knob
        const TOTAL_SWEEP = MAX_ANGLE - MIN_ANGLE; // 270 degrees

        /**
         * Maps a value from one range to a rotation angle.
         * @param {number} value The current value.
         * @param {number} min The minimum value of the range.
         * @param {number} max The maximum value of the range.
         * @returns {number} The rotation angle in degrees.
         */
        function mapValueToAngle(value, min, max) {
            const normalized = (value - min) / (max - min);
            // Ensure normalized is clamped between 0 and 1
            const clampedNormalized = Math.min(1, Math.max(0, normalized));
            return MIN_ANGLE + clampedNormalized * TOTAL_SWEEP;
        }

        /**
         * Updates the visual knob rotation and the concentric lighting fill.
         * @param {HTMLElement} knobFaceEl The rotating knob face element.
         * @param {HTMLInputElement} rangeEl The hidden range input element.
         * @param {HTMLElement} knobFillEl The static fill element.
         */
        function updateKnobVisuals(knobFaceEl, rangeEl, knobFillEl) {
            const value = parseFloat(rangeEl.value);
            const min = parseFloat(rangeEl.min);
            const max = parseFloat(rangeEl.max);
            
            // 1. Calculate Rotation Angle
            const angle = mapValueToAngle(value, min, max);
            // We use translate(-50%, -50%) to center it, then apply the rotation.
            knobFaceEl.style.transform = `translate(-50%, -50%) rotate(${angle}deg)`;

            // 2. Calculate Fill Percentage (0 to 1)
            const normalized = (value - min) / (max - min);
            // Map normalized value (0 to 1) to angle sweep (0deg to 270deg)
            const fillAngle = normalized * TOTAL_SWEEP;

            // 3. Update the Fill Background (Conic Gradient)
            const neonColor = getComputedStyle(document.documentElement).getPropertyValue('--neon-color');

            // The conic gradient starts at 0deg on the vertical axis, but the element is rotated 225deg (-135deg)
            // The fillAngle determines how much of the sweep is visible
            knobFillEl.style.background = `conic-gradient(
                ${neonColor} 0deg,
                ${neonColor} ${fillAngle}deg,
                transparent ${fillAngle}deg,
                transparent 360deg
            )`;
        }


        /**
         * Initializes the Web Audio Context and audio graph.
         * @returns {boolean} True if context started successfully.
         */
        async function initializeAudio() {
            try {
                if (!audioContext || audioContext.state === 'closed') {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                } else if (audioContext.state === 'suspended') {
                    await audioContext.resume();
                }

                stream = await navigator.mediaDevices.getUserMedia({ audio: true });

                sourceNode = audioContext.createMediaStreamSource(stream);
                hpfNode = audioContext.createBiquadFilter();
                gainNode = audioContext.createGain();

                // Configure HPF (High-Pass Filter)
                hpfNode.type = "highpass";
                hpfNode.frequency.setValueAtTime(parseFloat(hpfRange.value), audioContext.currentTime);

                // Configure Gain
                gainNode.gain.setValueAtTime(parseFloat(gainRange.value), audioContext.currentTime);

                // Build the Audio Graph: Source -> HPF -> Gain -> Destination (Speakers/Aux)
                sourceNode.connect(hpfNode);
                hpfNode.connect(gainNode);
                gainNode.connect(audioContext.destination);

                return true;

            } catch (error) {
                console.error("Error accessing microphone or initializing audio:", error);
                statusLight.className = 'w-4 h-4 rounded-full bg-red-500 shadow-lg';
                statusText.textContent = 'Error: Check mic permissions or device.';
                micToggle.checked = false; 
                return false;
            }
        }

        /**
         * Stops the audio stream and closes the context.
         */
        function stopAudio() {
            if (stream) {
                stream.getTracks().forEach(track => track.stop());
                stream = null;
            }
            if (audioContext && audioContext.state !== 'closed') {
                audioContext.close().catch(e => console.error("Error closing context:", e));
                audioContext = null;
            }
            sourceNode = null;
            hpfNode = null;
            gainNode = null;
            statusLight.className = 'w-4 h-4 rounded-full bg-gray-500 shadow-lg transition-all duration-300';
            statusText.textContent = 'Mic Disabled';
        }

        // --- UI & AUDIO UPDATE HANDLERS ---

        function updateGain() {
            const gainValue = parseFloat(gainRange.value);

            // 1. Update Audio Node
            if (gainNode) {
                if (audioContext && audioContext.state !== 'closed') {
                    gainNode.gain.setValueAtTime(gainValue, audioContext.currentTime);
                }
            }

            // 2. Update UI (Display as Percentage)
            const gainPercent = Math.round((gainValue / 3.0) * 100);
            gainValueDisplay.textContent = `${gainPercent}%`;

            // 3. Update Visual Knob (Rotation and Lighting)
            updateKnobVisuals(gainKnob, gainRange, gainFill);
        }

        function updateHPF() {
            const hpfFreq = parseFloat(hpfRange.value);

            // 1. Update Audio Node
            if (hpfNode) {
                if (audioContext && audioContext.state !== 'closed') {
                    // Use exponential ramp for frequency changes for a more natural sound
                    hpfNode.frequency.exponentialRampToValueAtTime(hpfFreq, audioContext.currentTime + 0.05);
                }
            }

            // 2. Update UI
            hpfValueDisplay.textContent = `${hpfFreq} Hz`;

            // 3. Update Visual Knob (Rotation and Lighting)
            updateKnobVisuals(hpfKnob, hpfRange, hpfFill);
        }

        /**
         * Main event listener for the mic toggle switch.
         */
        micToggle.addEventListener('change', async (event) => {
            if (event.target.checked) {
                statusLight.className = 'w-4 h-4 rounded-full bg-yellow-500 shadow-lg active animate-pulse';
                statusText.textContent = 'Starting Mic...';

                const success = await initializeAudio();

                if (success) {
                    statusLight.className = 'w-4 h-4 rounded-full bg-green-500 shadow-lg active';
                    statusText.textContent = 'Mic Active & Processing';
                    updateGain();
                    updateHPF();
                } else {
                    event.target.checked = false;
                }

            } else {
                stopAudio();
            }
        });

        // --- KNOB INTERACTION (DRAG/TOUCH) LOGIC ---
        let isDragging = false;
        let startY = 0;
        let activeRange = null;

        /**
         * Handles the start of a drag/touch gesture.
         */
        function startDrag(event, rangeEl) {
            event.preventDefault(); // Prevent text selection/scrolling
            isDragging = true;
            activeRange = rangeEl;
            startY = event.clientY || event.touches[0].clientY;
            rangeEl.previousElementSibling.style.cursor = 'grabbing';
        }

        /**
         * Handles the drag/move gesture.
         */
        function doDrag(event) {
            if (!isDragging || !activeRange) return;

            const currentY = event.clientY || event.touches[0].clientY;
            event.preventDefault(); // Prevent accidental mobile scrolling during touch move
            
            const deltaY = currentY - startY;

            // Get sensitivity from data attribute (High sensitivity for HPF, low for Gain)
            const sensitivity = parseFloat(activeRange.dataset.sensitivity || 0.1);

            // Moving UP (Y decreases, deltaY is negative) should increase value.
            // valueChange = -deltaY * sensitivity
            let valueChange = -deltaY * sensitivity;

            let currentValue = parseFloat(activeRange.value);
            const min = parseFloat(activeRange.min);
            const max = parseFloat(activeRange.max);
            const step = parseFloat(activeRange.step);

            // Update value
            let newValue = currentValue + valueChange;

            // Clamp the value to the min/max limits
            newValue = Math.min(max, Math.max(min, newValue));

            // Snap to step
            newValue = Math.round(newValue / step) * step;

            // Set the new value and trigger the input event
            if (newValue !== currentValue) {
                // Round final value to step's precision
                const precision = (step.toString().split('.')[1] || []).length;
                activeRange.value = newValue.toFixed(precision);
                activeRange.dispatchEvent(new Event('input'));
            }

            // Update startY for the next movement calculation
            startY = currentY;
        }

        /**
         * Handles the end of a drag/touch gesture.
         */
        function stopDrag() {
            if (isDragging && activeRange) {
                isDragging = false;
                activeRange.previousElementSibling.style.cursor = 'grab';
                activeRange = null;
            }
        }

        /**
         * Attaches drag, touch, and input handlers to a knob element.
         */
        function setupKnobInteraction(knobFaceEl, rangeEl, updateFn) {
            // 1. Setup Input Event Listener 
            rangeEl.addEventListener('input', updateFn);

            // 2. Setup Mouse Events for Dragging (attached to the visible knob face)
            knobFaceEl.addEventListener('mousedown', (e) => startDrag(e, rangeEl));
            document.addEventListener('mousemove', doDrag);
            document.addEventListener('mouseup', stopDrag);

            // 3. Setup Touch Events for Mobile Interaction
            knobFaceEl.addEventListener('touchstart', (e) => {
                startDrag(e, rangeEl);
            }, { passive: false }); 

            document.addEventListener('touchmove', doDrag, { passive: false });
            document.addEventListener('touchend', stopDrag);
        }

        // --- INITIAL SETUP (Run on Load) ---
        window.onload = () => {
            // Initialize drag and input handlers for both knobs
            setupKnobInteraction(gainKnob, gainRange, updateGain);
            setupKnobInteraction(hpfKnob, hpfRange, updateHPF);

            // Set initial rotation, lighting, and display values
            updateGain();
            updateHPF();

            // Resume audio context on first user interaction for compatibility
            document.addEventListener('click', () => {
                if (audioContext && audioContext.state === 'suspended') {
                    audioContext.resume();
                }
            }, { once: true });
        };

    </script>
</body>
</html>
